{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\nconst account_1 = require(\"./account\");\nconst bytes_1 = require(\"./bytes\");\n/**\n * Handling and generating Ethereum addresses\n */\nclass Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n  static zero() {\n    return new Address((0, bytes_1.zeros)(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str) {\n    if (!(0, account_1.isValidAddress)(str)) {\n      throw new Error('Invalid address');\n    }\n    return new Address((0, bytes_1.toBuffer)(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey) {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer');\n    }\n    const buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey) {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer');\n    }\n    const buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n    return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from, salt, initCode) {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer');\n    }\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer');\n    }\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n  equals(address) {\n    return this.buf.equals(address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress() {\n    const address = (0, bytes_1.bufferToBigInt)(this.buf);\n    const rangeMin = BigInt(0);\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n  toString() {\n    return '0x' + this.buf.toString('hex');\n  }\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer() {\n    return Buffer.from(this.buf);\n  }\n}\nexports.Address = Address;","map":null,"metadata":{},"sourceType":"script"}