{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\n// buf.toString('hex') -> toHex(buf)\nconst _assert_1 = __importDefault(require(\"@noble/hashes/_assert\"));\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\nvar utils_2 = require(\"@noble/hashes/utils\");\nObject.defineProperty(exports, \"bytesToHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"toHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"concatBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.concatBytes;\n  }\n});\nObject.defineProperty(exports, \"createView\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.createView;\n  }\n});\nObject.defineProperty(exports, \"utf8ToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_2.utf8ToBytes;\n  }\n});\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n  if (!(data instanceof Uint8Array)) {\n    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n  }\n  return new TextDecoder().decode(data);\n}\nexports.bytesToUtf8 = bytesToUtf8;\nfunction hexToBytes(data) {\n  const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n  return (0, utils_1.hexToBytes)(sliced);\n}\nexports.hexToBytes = hexToBytes;\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.equalsBytes = equalsBytes;\n// Internal utils\nfunction wrapHash(hash) {\n  return msg => {\n    _assert_1.default.bytes(msg);\n    return hash(msg);\n  };\n}\nexports.wrapHash = wrapHash;\nexports.crypto = (() => {\n  const webCrypto = typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined;\n  const nodeRequire = typeof module !== \"undefined\" && typeof module.require === \"function\" && module.require.bind(module);\n  return {\n    node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n    web: webCrypto\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}