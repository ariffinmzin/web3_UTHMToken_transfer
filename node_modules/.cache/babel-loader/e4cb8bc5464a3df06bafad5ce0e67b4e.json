{"ast":null,"code":"\"use strict\";\n\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\nconst async_1 = require(\"async\");\nconst events_1 = require(\"events\");\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let [data, callback] = args;\n    const self = this;\n    let listeners = self._events[event] ?? [];\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    }\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    }\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    (0, async_1.eachSeries)(listeners.slice(), function (fn, next) {\n      let err;\n      // Support synchronous functions\n      if (fn.length < 2) {\n        try {\n          fn.call(self, data);\n        } catch (e) {\n          err = e;\n        }\n        return next(err);\n      }\n      // Async\n      fn.call(self, data, next);\n    }, callback);\n    return self.listenerCount(event) > 0;\n  }\n  once(event, listener) {\n    const self = this;\n    let g;\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      g = function (e, next) {\n        self.removeListener(event, g);\n        void listener(e, next);\n      };\n    } else {\n      g = function (e) {\n        self.removeListener(event, g);\n        void listener(e, g);\n      };\n    }\n    self.on(event, g);\n    return self;\n  }\n  first(event, listener) {\n    let listeners = this._events[event] ?? [];\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    listeners.unshift(listener);\n    return this;\n  }\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    let listeners = this._events[event] ?? [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0;\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    index = listeners.length;\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n  eventNames() {\n    return super.eventNames();\n  }\n  listeners(event) {\n    return super.listeners(event);\n  }\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":null,"metadata":{},"sourceType":"script"}