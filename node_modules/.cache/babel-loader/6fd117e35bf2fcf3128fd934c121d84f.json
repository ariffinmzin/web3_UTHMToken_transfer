{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n   */\n  constructor(index, validatorIndex, address, amount) {\n    this.index = index;\n    this.validatorIndex = validatorIndex;\n    this.address = address;\n    this.amount = amount;\n  }\n  static fromWithdrawalData(withdrawalData) {\n    const {\n      index: indexData,\n      validatorIndex: validatorIndexData,\n      address: addressData,\n      amount: amountData\n    } = withdrawalData;\n    const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n    const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n    const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n    const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n    return new Withdrawal(index, validatorIndex, address, amount);\n  }\n  static fromValuesArray(withdrawalArray) {\n    if (withdrawalArray.length !== 4) {\n      throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n    }\n    const [index, validatorIndex, address, amount] = withdrawalArray;\n    return Withdrawal.fromWithdrawalData({\n      index,\n      validatorIndex,\n      address,\n      amount\n    });\n  }\n  /**\n   * Convert a withdrawal to a buffer array\n   * @param withdrawal the withdrawal to convert\n   * @returns buffer array of the withdrawal\n   */\n  static toBufferArray(withdrawal) {\n    const {\n      index,\n      validatorIndex,\n      address,\n      amount\n    } = withdrawal;\n    const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n    const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n    let addressBuffer;\n    if (address instanceof address_1.Address) {\n      addressBuffer = address.buf;\n    } else {\n      addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n    }\n    const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n    return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n  }\n  raw() {\n    return Withdrawal.toBufferArray(this);\n  }\n  toJSON() {\n    return {\n      index: (0, bytes_1.bigIntToHex)(this.index),\n      validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n      address: '0x' + this.address.buf.toString('hex'),\n      amount: (0, bytes_1.bigIntToHex)(this.amount)\n    };\n  }\n}\nexports.Withdrawal = Withdrawal;","map":null,"metadata":{},"sourceType":"script"}