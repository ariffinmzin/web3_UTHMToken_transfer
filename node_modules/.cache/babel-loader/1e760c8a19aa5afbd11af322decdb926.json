{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n  constructor() {\n    this.permits = 1;\n    this.promiseResolverQueue = [];\n  }\n  /**\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n  async acquire() {\n    if (this.permits > 0) {\n      this.permits -= 1;\n      return Promise.resolve(true);\n    }\n    // If there is no permit available, we return a promise that resolves once the semaphore gets\n    // signaled enough times that permits is equal to one.\n    return new Promise(resolver => this.promiseResolverQueue.push(resolver));\n  }\n  /**\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\n   * continue to execute in a future iteration of the event loop.\n   */\n  release() {\n    this.permits += 1;\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1;\n      const nextResolver = this.promiseResolverQueue.shift();\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  }\n}\nexports.Lock = Lock;","map":null,"metadata":{},"sourceType":"script"}