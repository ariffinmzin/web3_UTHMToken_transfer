{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionFactory = void 0;\nconst util_1 = require(\"@ethereumjs/util\");\nconst ethers_1 = require(\"ethers\");\nconst eip1559Transaction_1 = require(\"./eip1559Transaction\");\nconst eip2930Transaction_1 = require(\"./eip2930Transaction\");\nconst fromRpc_1 = require(\"./fromRpc\");\nconst legacyTransaction_1 = require(\"./legacyTransaction\");\nclass TransactionFactory {\n  // It is not possible to instantiate a TransactionFactory object.\n  constructor() {}\n  /**\n   * Create a transaction from a `txData` object\n   *\n   * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)\n   * @param txOptions - Options to pass on to the constructor of the transaction\n   */\n  static fromTxData(txData) {\n    let txOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!('type' in txData) || txData.type === undefined) {\n      // Assume legacy transaction\n      return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n    } else {\n      const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));\n      if (txType === 0) {\n        return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 1) {\n        return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);\n      } else if (txType === 2) {\n        return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);\n      } else {\n        throw new Error(`Tx instantiation with type ${txType} not supported`);\n      }\n    }\n  }\n  /**\n   * This method tries to decode serialized data.\n   *\n   * @param data - The data Buffer\n   * @param txOptions - The transaction options\n   */\n  static fromSerializedData(data) {\n    let txOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (data[0] <= 0x7f) {\n      // Determine the type.\n      let EIP;\n      switch (data[0]) {\n        case 1:\n          EIP = 2930;\n          break;\n        case 2:\n          EIP = 1559;\n          break;\n        default:\n          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);\n      }\n      if (EIP === 1559) {\n        return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);\n      } else {\n        // EIP === 2930\n        return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);\n      }\n    } else {\n      return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);\n    }\n  }\n  /**\n   * When decoding a BlockBody, in the transactions field, a field is either:\n   * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))\n   * A Buffer[] (Legacy Transaction)\n   * This method returns the right transaction.\n   *\n   * @param data - A Buffer or Buffer[]\n   * @param txOptions - The transaction options\n   */\n  static fromBlockBodyData(data) {\n    let txOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (Buffer.isBuffer(data)) {\n      return this.fromSerializedData(data, txOptions);\n    } else if (Array.isArray(data)) {\n      // It is a legacy transaction\n      return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);\n    } else {\n      throw new Error('Cannot decode transaction: unknown type input');\n    }\n  }\n  /**\n   *  Method to retrieve a transaction from the provider\n   * @param provider - An Ethers JsonRPCProvider\n   * @param txHash - Transaction hash\n   * @param txOptions - The transaction options\n   * @returns the transaction specified by `txHash`\n   */\n  static async fromEthersProvider(provider, txHash, txOptions) {\n    const prov = typeof provider === 'string' ? new ethers_1.ethers.providers.JsonRpcProvider(provider) : provider;\n    const txData = await prov.send('eth_getTransactionByHash', [txHash]);\n    const normedTx = (0, fromRpc_1.normalizeTxParams)(txData);\n    return TransactionFactory.fromTxData(normedTx, txOptions);\n  }\n}\nexports.TransactionFactory = TransactionFactory;","map":null,"metadata":{},"sourceType":"script"}